#include <CapacitiveSensor.h>
int led1 = 12;
int led2 = 11;
//int led3 = 10;
int led1State = LOW;
int led2State = LOW;
//int led3State = LOW;
unsigned long csSum;
/*
 * CapitiveSense Library Demo Sketch
 * Paul Badger 2008
 * Uses a high value resistor e.g. 10M between send pin and receive pin
 * Resistor effects sensitivity, experiment with values, 50K - 50M. Larger resistor values yield larger sensor values.
 * Receive pin is the sensor pin - try different amounts of foil/metal on this pin
 */


CapacitiveSensor   cs_4_2 = CapacitiveSensor(4,2);        // 10M resistor between pins 4 & 2, pin 2 is sensor pin, add a wire and or foil if desired


void setup()                    
{
   cs_4_2.set_CS_AutocaL_Millis(0xFFFFFFFF);     // turn off autocalibrate on channel 1 - just as an example
   Serial.begin(9600);
   pinMode(led1, OUTPUT);
   led1State = LOW;
    led2State = LOW;
    led3State = LOW;
   
}

void loop()                    
{
  digitalWrite (led1, led1State);
  digitalWrite (led2, led2State);
  digitalWrite (led3, led3State);
  
  CSread();                           // arbitrary delay to limit data to serial port 
  delay(100);
}

void CSread() {
    long cs = cs_4_2.capacitiveSensor(240); //a: Sensor resolution is set to 80
  if (cs > 370) { //b: Arbitrary number
    csSum += cs;
    Serial.print("TOUCHING");
    Serial.println(cs); 
    if (csSum >= 15000) //c: This value is the threshold, a High value means it takes longer to trigger
    {
      Serial.print("Trigger: ");
      Serial.println(csSum);
      led2State = HIGH;
      led1State = HIGH;
      if (csSum > 0) { csSum = 0; } //Reset
      cs_4_2.reset_CS_AutoCal(); //Stops readings
    }
  }
 // else if (csSum >= 30000){
 //   led2State = HIGH;
 // }
 // else if (csSum >= 60000){
 //   led3State = HIGH;
 // }
  else {
    //led2State = LOW;
    Serial.print("NOT TOUCHING");
    Serial.println(cs);
    csSum = 0; //Timeout caused by bad readings
  }

}
